<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Danh S√°ch ·ª®ng Vi√™n</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet" />
    <link rel="stylesheet" th:href="@{/css/language-switcher.css}" />
    <link rel="stylesheet" th:href="@{/css/navbarHome.css}" />
    <link rel="stylesheet" th:href="@{/css/navbar.css}" />
    <link rel="stylesheet" th:href="@{/css/navbarEnhanced.css}" />
    <link rel="stylesheet" th:href="@{/css/navbarEmployer.css}" />
    <link rel="stylesheet" th:href="@{/css/viewListApplication.css}" />
    <link rel="stylesheet" th:href="@{/css/language_sidebar.css}" />
    <style>
        /* Fix dropdown overflow issues */
        .table-container {
            overflow: visible !important;
        }
        
        table {
            overflow: visible !important;
        }
        
        tbody {
            overflow: visible !important;
        }
        
        tbody tr {
            position: relative;
            overflow: visible !important;
        }
        
        tbody td {
            overflow: visible !important;
            position: relative;
        }
        
        .action-buttons {
            position: relative;
            overflow: visible !important;
        }
        
        .dropdown {
            position: relative !important;
            overflow: visible !important;
        }
        
        /* Ensure dropdown shows on top */
        .dropdown-menu {
            position: absolute !important;
            z-index: 9999 !important;
            min-width: 10rem;
            padding: 0.5rem 0;
            margin: 0;
            font-size: 0.875rem;
            color: #212529;
            text-align: left;
            list-style: none;
            background-color: #fff;
            background-clip: padding-box;
            border: 1px solid rgba(0,0,0,.15);
            border-radius: 0.375rem;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15) !important;
            top: 100% !important;
            left: auto !important;
            right: 0 !important;
            transform: none !important;
        }
        
        .dropdown-item {
            display: block !important;
            width: 100% !important;
            padding: 0.375rem 1rem !important;
            clear: both;
            font-weight: 400;
            color: #212529 !important;
            text-align: inherit;
            text-decoration: none;
            white-space: nowrap;
            background-color: transparent;
            border: 0;
        }
        
        .dropdown-item:hover {
            background-color: #e9ecef !important;
        }
        
        .dropdown-item:disabled {
            color: #6c757d !important;
            background-color: transparent !important;
        }
        
        /* Force visibility of dropdown toggle */
        .dropdown-toggle {
            background: transparent !important;
            border: 1px solid #dee2e6 !important;
        }
        
        .dropdown-toggle::after {
            display: inline-block;
            margin-left: 0.255em;
            vertical-align: 0.255em;
            content: "";
            border-top: 0.3em solid;
            border-right: 0.3em solid transparent;
            border-bottom: 0;
            border-left: 0.3em solid transparent;
        }

        /* N√∫t CV nh·ªè g·ªçn */
        .btn-cv {
            background: linear-gradient(90deg, #7c3aed 0%, #a78bfa 100%);
            color: #fff !important;
            border: 2px solid #7c3aed;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.75rem;
            padding: 4px 8px;
            box-shadow: 0 2px 8px rgba(80, 37, 196, 0.12);
            transition: background 0.2s, color 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .btn-cv:hover, .btn-cv:focus {
            background: linear-gradient(90deg, #a78bfa 0%, #7c3aed 100%);
            color: #fff;
            box-shadow: 0 4px 16px rgba(80, 37, 196, 0.18);
            border-color: #a78bfa;
        }
        .btn-cv i {
            font-size: 0.8em;
            color: #fff !important;
        }

        /* N√∫t Chat xanh l√° */
        .btn-chat {
            background: linear-gradient(135deg, #25d366 0%, #128c7e 100%);
            color: white !important;
            border: 2px solid #25d366;
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 0.75rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(37, 211, 102, 0.3);
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .btn-chat:hover {
            background: linear-gradient(135deg, #128c7e 0%, #075e54 100%);
            color: white !important;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(37, 211, 102, 0.4);
            border-color: #128c7e;
        }
        .btn-chat i {
            font-size: 0.8em;
            color: white !important;
        }

        /* Off-canvas Chat Styles */
        .chat-offcanvas {
            position: fixed;
            top: 0;
            right: -450px;
            width: 450px;
            height: 100vh;
            background: #fff;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
            transition: right 0.3s ease;
            z-index: 10000;
            display: flex;
            flex-direction: column;
        }

        .chat-offcanvas.show {
            right: 0;
        }

        .chat-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .chat-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        /* Chat Header */
        .chat-header {
            display: flex;
            align-items: center;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom: 1px solid #e0e0e0;
        }

        .chat-header .avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-weight: bold;
            color: #667eea;
            font-size: 18px;
        }

        .chat-header .info h4 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .chat-header .info p {
            margin: 0;
            font-size: 12px;
            opacity: 0.8;
        }

        .chat-header .close-btn {
            margin-left: auto;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .chat-header .close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Chat Messages */
        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-end;
        }

        .message.sent {
            justify-content: flex-end;
        }

        .message.received {
            justify-content: flex-start;
        }

        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
            position: relative;
        }

        .message.sent .message-bubble {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message.received .message-bubble {
            background: white;
            color: #333;
            border: 1px solid #e0e0e0;
            border-bottom-left-radius: 4px;
        }

        .message-time {
            font-size: 11px;
            opacity: 0.7;
            margin-top: 5px;
            text-align: right;
        }

        .message.received .message-time {
            text-align: left;
        }

        /* Chat Input */
        .chat-input {
            padding: 20px;
            background: white;
            border-top: 1px solid #e0e0e0;
        }

        .chat-input-form {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chat-input-form input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 25px;
            outline: none;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .chat-input-form input:focus {
            border-color: #667eea;
        }

        .chat-input-form button {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s;
        }

        .chat-input-form button:hover {
            transform: scale(1.05);
        }

        /* Typing Indicator */
        .typing-indicator {
            display: none;
            padding: 10px 20px;
            font-size: 12px;
            color: #666;
            font-style: italic;
        }

        .typing-dots {
            display: inline-block;
            margin-left: 5px;
        }

        .typing-dots span {
            display: inline-block;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: #667eea;
            margin: 0 1px;
            animation: typingDots 1.4s infinite ease-in-out;
        }

        .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
        .typing-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes typingDots {
            0%, 80%, 100% { transform: scale(0); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .chat-offcanvas {
                width: 100%;
                right: -100%;
            }
        }
    </style>
</head>
<body>
<div th:replace="~{navbar/navbarEmployee :: navbarEmployee}"></div>

<div class="main-content">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h1>Danh S√°ch ·ª®ng Vi√™n</h1>
        <button class="btn btn-primary" onclick="showAllChatRooms()" title="Xem t·∫•t c·∫£ cu·ªôc tr√≤ chuy·ªán">
            <i class="bi bi-chat-text"></i> Danh s√°ch Chat
        </button>
    </div>

    <div th:if="${successMessage}" class="alert alert-success alert-dismissible fade show" role="alert">
        <span th:text="${successMessage}"></span>
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    </div>
    <div th:if="${errorMessage}" class="alert alert-danger alert-dismissible fade show" role="alert">
        <span th:text="${errorMessage}"></span>
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    </div>

    <div class="search-section mb-4">
        <form method="get" class="row g-3">
            <div class="col-md-8">
                <div class="input-group">
                    <span class="input-group-text">
                        <i class="bi bi-search"></i>
                    </span>
                    <input type="text"
                           name="searchName"
                           class="form-control"
                           placeholder="T√¨m ki·∫øm theo t√™n ·ª©ng vi√™n..."
                           th:value="${searchName}">
                </div>
            </div>
            <div class="col-md-4">
                <button type="submit" class="btn btn-primary me-2">
                    <i class="bi bi-search"></i> T√¨m ki·∫øm
                </button>
                <a th:href="@{/Employer/Applications}" class="btn btn-outline-secondary">
                    <i class="bi bi-arrow-clockwise"></i> Reset
                </a>
            </div>
        </form>
    </div>

    <div class="table-container">
        <div th:if="${applications == null or applications.content.isEmpty()}" class="empty-state">
            <i class="bi bi-person-x"></i>
            <h3 th:if="${searchName != null and !searchName.isEmpty()}">Kh√¥ng t√¨m th·∫•y ·ª©ng vi√™n n√†o</h3>
            <h3 th:unless="${searchName != null and !searchName.isEmpty()}">Ch∆∞a c√≥ ·ª©ng vi√™n n√†o</h3>
            <p th:if="${searchName != null and !searchName.isEmpty()}">
                Kh√¥ng t√¨m th·∫•y ·ª©ng vi√™n n√†o v·ªõi t√™n "<span th:text="${searchName}"></span>"
            </p>
            <p th:unless="${searchName != null and !searchName.isEmpty()}">
                Hi·ªán t·∫°i ch∆∞a c√≥ ·ª©ng vi√™n n√†o ·ª©ng tuy·ªÉn v√†o c√°c v·ªã tr√≠ c·ªßa b·∫°n.
            </p>
        </div>

        <div th:if="${applications != null and !applications.content.isEmpty()}">
            <!-- Pagination info -->
            <div class="pagination-info mb-3">
                <span class="text-muted">
                    Hi·ªÉn th·ªã <strong th:text="${applications.numberOfElements}">0</strong>
                    trong t·ªïng s·ªë <strong th:text="${applications.totalElements}">0</strong> ·ª©ng vi√™n
                    <span th:if="${searchName != null and !searchName.isEmpty()}">
                        cho t·ª´ kh√≥a "<strong th:text="${searchName}"></strong>"
                    </span>
                    (Trang <strong th:text="${applications.number + 1}">1</strong>
                    / <strong th:text="${applications.totalPages}">1</strong>)
                </span>
            </div>

            <table>
                <thead>
                <tr>
                    <th>STT</th>
                    <th>T√™n ·ª©ng vi√™n</th>
                    <th>Email & Phone</th>
                    <th>V·ªã tr√≠ ·ª©ng tuy·ªÉn</th>
                    <th>Ng√†y ·ª©ng tuy·ªÉn</th>
                    <th>Tr·∫°ng th√°i</th>
                    <th>H√†nh ƒë·ªông</th>
                </tr>
                </thead>
                <tbody>
                <th:block th:each="jobApplication, iterStat : ${applications.content}">
                    <!-- Main row -->
                    <tr>
                        <td th:text="${(applications.number * applications.size) + iterStat.count}"></td>
                        <td>
                            <div class="candidate-name">
                                <strong th:text="${jobApplication.fullName}"></strong>
                            </div>
                        </td>
                        <td>
                            <div class="candidate-contact">
                                <small class="text-muted" th:text="${jobApplication.email}"></small>
                                <br>
                                <small class="text-muted" th:if="${jobApplication.phone}" th:text="${jobApplication.phone}"></small>
                            </div>
                        </td>
                        <td>
                            <span class="job-title" th:text="${jobApplication.jobPost.jobTitle}"></span>
                        </td>
                        <td>
                            <span th:text="${#temporals.format(jobApplication.appliedAt, 'dd/MM/yyyy HH:mm')}"></span>
                        </td>
                        <td>
                            <span class="status-badge"
                                  th:classappend="${jobApplication.status.toString().toLowerCase()}"
                                  th:text="${jobApplication.status}"></span>
                        </td>
                        <td>
                            <div class="cell action-col" style="display: flex; align-items: center; gap: 8px; justify-content: center;">
                                <button class="btn-cv" th:onclick="'toggleDetails(' + ${iterStat.index} + ')'" th:id="'btn-details-' + ${iterStat.index}">
                                    <i class="bi bi-chevron-down"></i>
                                    <span>Xem CV</span>
                                </button>
                            </div>
                        </td>
                    </tr>
                    <!-- Details row hi·ªán ngay d∆∞·ªõi m·ªói row -->
                    <tr class="details-row" th:id="'details-' + ${iterStat.index}" style="display: none;">
                        <td colspan="7" style="padding: 0;">
                            <div class="details-content">
                                <!-- Ch·ªâ hi·ªán CV -->
                                <div th:if="${jobApplication.cvUrl != null and !#strings.isEmpty(jobApplication.cvUrl)}" style="text-align: center; margin: 0 auto; max-width: 800px;">
                                    <h4 style="text-align: center; margin-bottom: 20px; color: #374151;"><i class="bi bi-file-earmark-text"></i> CV c·ªßa ·ª©ng vi√™n</h4>
                                    <img th:if="${#strings.endsWith(jobApplication.cvUrl, '.jpg') or #strings.endsWith(jobApplication.cvUrl, '.jpeg') or #strings.endsWith(jobApplication.cvUrl, '.png') or #strings.endsWith(jobApplication.cvUrl, '.gif')}"
                                         th:src="${jobApplication.cvUrl}" alt="CV Image" style="max-width:100%; max-height:800px; display:block; margin:0 auto; border-radius: 8px; box-shadow: 0 4px 16px rgba(80,37,196,0.12);"/>
                                    
                                    <iframe th:if="${!(#strings.endsWith(jobApplication.cvUrl, '.jpg') or #strings.endsWith(jobApplication.cvUrl, '.jpeg') or #strings.endsWith(jobApplication.cvUrl, '.png') or #strings.endsWith(jobApplication.cvUrl, '.gif'))}"
                                            th:src="'https://docs.google.com/viewer?url=' + ${jobApplication.cvUrl} + '&embedded=true'"
                                            style="width:100%; height:800px; border:none; border-radius: 8px; box-shadow: 0 4px 16px rgba(80,37,196,0.12);">
                                    </iframe>
                                </div>
                            </div>
                        </td>
                    </tr>
                </th:block>
                </tbody>
            </table>
        </div>
    </div>

    <div th:if="${applications != null and !applications.content.isEmpty()}" class="simple-pagination">
        <!-- Previous button -->
        <a th:if="${applications.hasPrevious()}"
           th:href="@{/Employer/Applications(page=${applications.number - 1}, size=${applications.size}, searchName=${searchName})}"
           class="btn btn-outline-primary me-2">
            <i class="bi bi-chevron-left"></i> Trang tr∆∞·ªõc
        </a>
        <span th:unless="${applications.hasPrevious()}" class="btn btn-outline-secondary me-2 disabled">
            <i class="bi bi-chevron-left"></i> Trang tr∆∞·ªõc
        </span>

        <span class="mx-3 page-info">
            Trang <strong th:text="${applications.number + 1}">1</strong>
            / <strong th:text="${applications.totalPages}">1</strong>
        </span>

        <a th:if="${applications.hasNext()}"
           th:href="@{/Employer/Applications(page=${applications.number + 1}, size=${applications.size}, searchName=${searchName})}"
           class="btn btn-outline-primary ms-2">
            Trang sau <i class="bi bi-chevron-right"></i>
        </a>
        <span th:unless="${applications.hasNext()}" class="btn btn-outline-secondary ms-2 disabled">
            Trang sau <i class="bi bi-chevron-right"></i>
        </span>
    </div>
</div>

<!-- ƒê√£ chuy·ªÉn Chat v√† Interview actions sang /Employer/JobPosts/{id}/applications -->

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
// Initialize Bootstrap dropdowns
document.addEventListener('DOMContentLoaded', function() {
    // Wait a bit for content to load
    setTimeout(function() {
        // Initialize Bootstrap dropdowns - s·ª≠ d·ª•ng th∆∞ vi·ªán Bootstrap
        var dropdownElementList = [].slice.call(document.querySelectorAll('.dropdown-toggle'));
        console.log('Found', dropdownElementList.length, 'dropdown toggles');
        
        var dropdownList = dropdownElementList.map(function (dropdownToggleEl) {
            console.log('Initializing dropdown:', dropdownToggleEl.id);
            return new bootstrap.Dropdown(dropdownToggleEl, {
                boundary: 'viewport',
                display: 'dynamic'
            });
        });
        
        console.log('Initialized', dropdownList.length, 'dropdowns');
        
        // Manual click handlers as backup
        dropdownElementList.forEach(function(toggle) {
            toggle.addEventListener('click', function(e) {
                console.log('Dropdown clicked:', this.id);
                e.preventDefault();
                e.stopPropagation();
                
                // Close other dropdowns
                document.querySelectorAll('.dropdown-menu.show').forEach(function(menu) {
                    menu.classList.remove('show');
                });
                
                // Toggle current dropdown
                var menu = this.nextElementSibling;
                if (menu && menu.classList.contains('dropdown-menu')) {
                    menu.classList.toggle('show');
                }
            });
        });
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.dropdown')) {
                document.querySelectorAll('.dropdown-menu.show').forEach(function(menu) {
                    menu.classList.remove('show');
                });
            }
        });
    }, 100);
});

// DEPRECATED: handleStatusClick - ƒê√£ chuy·ªÉn sang JobPostController
// T·∫•t c·∫£ actions ƒë√£ ƒë∆∞·ª£c chuy·ªÉn sang /Employer/JobPosts/{id}/applications

function toggleDetails(index) {
    const detailsRow = document.getElementById('details-' + index);
    const button = document.getElementById('btn-details-' + index);
    const icon = button.querySelector('i');
    const text = button.querySelector('span');
    
    if (detailsRow.classList.contains('show')) {
        detailsRow.classList.remove('show');
        detailsRow.style.display = 'none';
        icon.className = 'bi bi-chevron-down';
        text.textContent = 'CV';
        button.classList.remove('expanded');
    } else {
        detailsRow.style.display = 'table-row';
        setTimeout(() => {
            detailsRow.classList.add('show');
        }, 10);
        icon.className = 'bi bi-chevron-up';
        text.textContent = 'CV';
        button.classList.add('expanded');
        
        // Scroll to the details row
        setTimeout(() => {
            detailsRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 200);
    }
}

// Chat WebSocket Client
let chatWebSocketClient = null;
let currentChatRoomId = null;
let currentUserId = null;
let currentUserName = null;

// Initialize WebSocket when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Get current user info using correct endpoint
    fetch('/api/chat/current-user')
        .then(response => response.json())
        .then(userInfo => {
            currentUserId = userInfo.userId;
            currentUserName = userInfo.fullName;
            initializeWebSocket();
            console.log('‚úÖ User info loaded:', userInfo);
        })
        .catch(error => {
            console.log('Could not load user info, using fallback');
            // Fallback - you can set default values or get from session
            currentUserId = 1; // Default employer ID
            currentUserName = "Employer";
            initializeWebSocket();
        });
});

function initializeWebSocket() {
    if (window.ChatWebSocketClient) {
        chatWebSocketClient = new ChatWebSocketClient();
        
        // Set callbacks with debug
        chatWebSocketClient.onMessageReceived = (message) => {
            console.log('üîÑ WebSocket callback triggered with message:', message);
            handleNewMessage(message);
        };
        chatWebSocketClient.onConnected = () => console.log('‚úÖ Chat WebSocket connected');
        chatWebSocketClient.onError = (error) => console.error('‚ùå Chat error:', error);
        
        // Connect to WebSocket
        chatWebSocketClient.connect(currentUserId, currentUserName);
    }
}

/**
 * üéØ Chat tr·ª±c ti·∫øp v·ªõi student c·ª• th·ªÉ
 * ƒê∆∞·ª£c g·ªçi khi b·∫•m n√∫t "Chat" b√™n c·∫°nh t√™n ·ª©ng vi√™n
 */
function openChatFromButton(button) {
    const userName = button.getAttribute('data-user-name');
    const userEmail = button.getAttribute('data-user-email');
    
    console.log('üéØ Opening direct chat with student:', userName, userEmail);
    
    if (!userName || !userEmail) {
        console.error('‚ùå Missing user data on button');
        alert('Kh√¥ng th·ªÉ l·∫•y th√¥ng tin ·ª©ng vi√™n. Vui l√≤ng th·ª≠ l·∫°i.');
        return;
    }
    
    // Chat tr·ª±c ti·∫øp v·ªõi student n√†y
    openDirectChatWithStudent(userName, userEmail);
}

function showChatRoomsPanel() {
    // Show chat overlay
    document.getElementById('chatOverlay').classList.add('show');
    document.getElementById('chatOffcanvas').classList.add('show');
    
    // Show rooms list in the chat area
    loadAllChatRooms();
}

/**
 * üìã Hi·ªÉn th·ªã danh s√°ch t·∫•t c·∫£ chat rooms
 * ƒê∆∞·ª£c g·ªçi khi b·∫•m n√∫t "Danh s√°ch Chat" ·ªü header
 */
function showAllChatRooms() {
    console.log('üìã Opening chat rooms list panel');
    
    // Show chat panel with rooms list
    showChatRoomsPanel();
}

function showChatRoomsPanel() {
    // Show chat overlay
    document.getElementById('chatOverlay').classList.add('show');
    document.getElementById('chatOffcanvas').classList.add('show');

    // Show rooms list in the chat area
    loadAllChatRooms();
}

// Function to open direct chat with a specific student
function openDirectChatWithStudent(userName, userEmail) {
    console.log('üöÄ Opening direct chat with:', userName, userEmail);
    
    // Update chat header info
    document.getElementById('chatName').textContent = userName;
    document.getElementById('chatAvatar').textContent = userName.charAt(0).toUpperCase();
    document.getElementById('chatStatus').textContent = 'ƒêang ho·∫°t ƒë·ªông';

    // Show chat off-canvas
    document.getElementById('chatOverlay').classList.add('show');
    document.getElementById('chatOffcanvas').classList.add('show');
    
    // Hide back button since we're going directly to chat
    const backBtn = document.getElementById('chatBackBtn');
    if (backBtn) {
        backBtn.style.display = 'none';
    }

    // Try to find or create chat room with this student
    tryCreateChatRoomWithStudent(userName, userEmail);
}

function openChat(userName, userEmail) {
    // Update chat header info
    document.getElementById('chatName').textContent = userName;
    document.getElementById('chatAvatar').textContent = userName.charAt(0).toUpperCase();
    
    // Show chat off-canvas
    document.getElementById('chatOverlay').classList.add('show');
    document.getElementById('chatOffcanvas').classList.add('show');
    
    // Focus on input
    setTimeout(() => {
        document.getElementById('messageInput').focus();
    }, 300);
    
    // Load/Create chat room with this user
    loadChatRoom(userEmail);
}

async function loadAllChatRooms() {
    try {
        console.log('üìã Loading all chat rooms for employer...');
        
        const roomsResponse = await fetch('/api/chat/rooms');
        if (!roomsResponse.ok) {
            throw new Error('Failed to load rooms');
        }
        
        const rooms = await roomsResponse.json();
        console.log('üìã Found rooms:', rooms);
        
        // Show rooms list in chat area
        showChatRoomsList(rooms);
        
    } catch (error) {
        console.error('‚ùå Error loading chat rooms:', error);
        showRoomsError();
    }
}

function showChatRoomsList(rooms) {
    const messagesContainer = document.getElementById('chatMessages');
    
    if (!rooms || rooms.length === 0) {
        messagesContainer.innerHTML = `
            <div style="text-align: center; padding: 40px 20px; color: #666;">
                <div style="font-size: 48px; margin-bottom: 20px;">üí¨</div>
                <h4 style="margin: 0 0 10px 0; color: #333;">Ch∆∞a c√≥ cu·ªôc tr√≤ chuy·ªán n√†o</h4>
                <p style="margin: 0; font-size: 14px;">
                    C√°c cu·ªôc tr√≤ chuy·ªán v·ªõi ·ª©ng vi√™n s·∫Ω xu·∫•t hi·ªán ·ªü ƒë√¢y
                </p>
            </div>
        `;
        
        // Update header for empty state
        document.getElementById('chatName').textContent = 'Danh s√°ch cu·ªôc tr√≤ chuy·ªán';
        document.getElementById('chatAvatar').textContent = 'üí¨';
        document.getElementById('chatStatus').textContent = 'Ch·ªçn cu·ªôc tr√≤ chuy·ªán';
        
        // Hide back button for rooms list
        const backBtn = document.getElementById('chatBackBtn');
        if (backBtn) backBtn.style.display = 'none';
        
        // Disable input for rooms list
        const messageInput = document.getElementById('messageInput');
        if (messageInput) {
            messageInput.disabled = true;
            messageInput.placeholder = 'Ch·ªçn cu·ªôc tr√≤ chuy·ªán ƒë·ªÉ g·ª≠i tin nh·∫Øn...';
        }
        
        return;
    }
    
    // Update header for rooms list
    document.getElementById('chatName').textContent = `Cu·ªôc tr√≤ chuy·ªán (${rooms.length})`;
    document.getElementById('chatAvatar').textContent = 'üí¨';
    document.getElementById('chatStatus').textContent = 'Ch·ªçn cu·ªôc tr√≤ chuy·ªán';
    
    // Hide back button for rooms list
    const backBtn = document.getElementById('chatBackBtn');
    if (backBtn) backBtn.style.display = 'none';
    
    // Disable input for rooms list
    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
        messageInput.disabled = true;
        messageInput.placeholder = 'Ch·ªçn cu·ªôc tr√≤ chuy·ªán ƒë·ªÉ g·ª≠i tin nh·∫Øn...';
    }
    
    // Create rooms list HTML
    const roomsHTML = rooms.map(room => {
        const participantName = room.participantName || room.otherParticipantName || 'Ng∆∞·ªùi d√πng';
        const lastMessage = room.lastMessage || 'Ch∆∞a c√≥ tin nh·∫Øn';
        const lastMessageTime = room.lastMessageAt ? new Date(room.lastMessageAt).toLocaleTimeString('vi-VN', { 
            hour: '2-digit', 
            minute: '2-digit' 
        }) : '';
        const avatar = participantName.charAt(0).toUpperCase();
        const unreadBadge = room.unreadCount > 0 ? `<span style="background: #ff4757; color: white; font-size: 11px; padding: 2px 6px; border-radius: 10px; margin-left: 5px;">${room.unreadCount}</span>` : '';
        
        return `
            <div class="chat-room-item" onclick="openChatRoom(${room.chatRoomId}, '${participantName}')" 
                 style="display: flex; align-items: center; padding: 15px; border-bottom: 1px solid #eee; cursor: pointer; transition: background 0.2s; border-radius: 8px; margin-bottom: 5px;"
                 onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='white'">
                
                <div style="width: 45px; height: 45px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                           color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 15px; font-size: 18px;">
                    ${avatar}
                </div>
                
                <div style="flex: 1; min-width: 0;">
                    <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 5px;">
                        <h6 style="margin: 0; font-weight: 600; color: #333; font-size: 15px;">${participantName}</h6>
                        <div style="display: flex; align-items: center;">
                            <small style="color: #666; font-size: 12px;">${lastMessageTime}</small>
                            ${unreadBadge}
                        </div>
                    </div>
                    <p style="margin: 0; color: #666; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                        ${lastMessage}
                    </p>
                </div>
            </div>
        `;
    }).join('');
    
    messagesContainer.innerHTML = `
        <div style="padding: 10px;">
            <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;">
                <small style="color: #666; font-size: 12px;">
                    üì± Ch·ªçn cu·ªôc tr√≤ chuy·ªán ƒë·ªÉ b·∫Øt ƒë·∫ßu nh·∫Øn tin v·ªõi ·ª©ng vi√™n
                </small>
            </div>
            ${roomsHTML}
        </div>
    `;
}

function openChatRoom(roomId, participantName) {
    console.log('üîì Opening chat room:', roomId, 'with participant:', participantName);
    
    // Update header for individual chat
    document.getElementById('chatName').textContent = participantName;
    document.getElementById('chatAvatar').textContent = participantName.charAt(0).toUpperCase();
    document.getElementById('chatStatus').textContent = 'ƒêang ho·∫°t ƒë·ªông';
    
    // Show back button for individual chat
    const backBtn = document.getElementById('chatBackBtn');
    if (backBtn) backBtn.style.display = 'inline-block';
    
    // Set current room
    currentChatRoomId = String(roomId);
    
    // Join WebSocket room  
    if (chatWebSocketClient && chatWebSocketClient.isConnected) {
        chatWebSocketClient.joinRoom(Number(roomId)); // Convert back to number for WebSocket
        
        // Mark messages as read
        markMessagesAsRead(roomId);
    }
    
    // Load chat history
    loadChatHistory(roomId);
    
    // Enable input
    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
        messageInput.disabled = false;
        messageInput.placeholder = `Nh·∫≠p tin nh·∫Øn cho ${participantName}...`;
        
        // Focus on input
        setTimeout(() => {
            messageInput.focus();
        }, 500);
    }
}

function showRoomsError() {
    const messagesContainer = document.getElementById('chatMessages');
    messagesContainer.innerHTML = `
        <div style="text-align: center; padding: 40px 20px; color: #dc3545;">
            <div style="font-size: 48px; margin-bottom: 20px;">‚ö†Ô∏è</div>
            <h4 style="margin: 0 0 10px 0;">Kh√¥ng th·ªÉ t·∫£i cu·ªôc tr√≤ chuy·ªán</h4>
            <p style="margin: 0 0 20px 0; font-size: 14px;">
                Vui l√≤ng th·ª≠ l·∫°i sau
            </p>
            <button onclick="loadAllChatRooms()" style="background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                Th·ª≠ l·∫°i
            </button>
        </div>
    `;
    
    // Update header for error state
    document.getElementById('chatName').textContent = 'L·ªói t·∫£i cu·ªôc tr√≤ chuy·ªán';
    document.getElementById('chatAvatar').textContent = '‚ö†Ô∏è';
    document.getElementById('chatStatus').textContent = 'Vui l√≤ng th·ª≠ l·∫°i';
}

// Handle new messages from WebSocket
function handleNewMessage(message) {
    console.log('üì® New message received in handleNewMessage:', message);
    console.log('üîç Current room ID:', currentChatRoomId, 'Message room ID:', message.chatRoomId);
    
    // If we're currently in a specific chat room, add message to UI
    if (currentChatRoomId && message.chatRoomId == Number(currentChatRoomId)) {
        console.log('‚úÖ Adding message to current chat UI');
        addMessageToUI(message);
    } else {
        console.log('‚ö†Ô∏è Message not for current room or no room selected');
    }
    
    // If we're in rooms list view, refresh the list to show new message
    const chatName = document.getElementById('chatName');
    if (chatName && chatName.textContent.includes('Cu·ªôc tr√≤ chuy·ªán')) {
        console.log('üîÑ Refreshing rooms list due to new message');
        loadAllChatRooms();
    }
}

function addMessageToUI(message) {
    const messagesContainer = document.getElementById('chatMessages');
    if (!messagesContainer) return;
    
    const isSent = message.senderId == currentUserId;
    const messageClass = isSent ? 'sent' : 'received';
    
    const messageHTML = `
        <div class="message ${messageClass}">
            <div class="message-bubble">
                ${message.content}
                <div class="message-time">${formatMessageTime(message.sentAt)}</div>
            </div>
        </div>
    `;
    
    messagesContainer.insertAdjacentHTML('beforeend', messageHTML);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function formatMessageTime(timeString) {
    if (!timeString) return '';
    
    const date = new Date(timeString);
    return date.toLocaleTimeString('vi-VN', { 
        hour: '2-digit', 
        minute: '2-digit' 
    });
}

async function loadChatRoom(userEmail) {
    try {
        console.log('üîç Loading chat room for email:', userEmail);
        
        // For now, we'll use a simplified approach
        // We'll create a demo room and load existing rooms to find one
        
        // First, try to get existing chat rooms
        const roomsResponse = await fetch('/api/chat/rooms');
        if (roomsResponse.ok) {
            const rooms = await roomsResponse.json();
            console.log('üìã Existing rooms:', rooms);
            
            // Try to find a room for this email (basic matching)
            const existingRoom = rooms.find(room => 
                room.otherParticipantName && 
                room.otherParticipantName.includes(userEmail.split('@')[0])
            );
            
            if (existingRoom) {
                console.log('‚úÖ Found existing room:', existingRoom);
                currentChatRoomId = String(existingRoom.chatRoomId);
                
                // Join WebSocket room
                if (chatWebSocketClient && chatWebSocketClient.isConnected) {
                    chatWebSocketClient.joinRoom(Number(currentChatRoomId));
                }
                
                // Load chat history
                loadChatHistory(currentChatRoomId);
                return;
            }
        }
        
        // If no existing room found, show preparation message
        console.log('üìù No existing room found, showing preparation message');
        createChatRoomByEmail(userEmail);
        
    } catch (error) {
        console.error('Error loading chat room:', error);
        createChatRoomByEmail(userEmail);
    }
}

// Function to try creating REAL chat room with specific student
async function tryCreateChatRoomWithStudent(userName, userEmail) {
    try {
        console.log('üîç Finding student by email:', userEmail);
        
        // First, try to find existing chat rooms
        const roomsResponse = await fetch('/api/chat/rooms');
        if (roomsResponse.ok) {
            const rooms = await roomsResponse.json();
            console.log('üìã Existing rooms:', rooms);
            
            // Try to find a room for this student
            const existingRoom = rooms.find(room => 
                room.otherParticipantName && 
                (room.otherParticipantName.toLowerCase().includes(userName.toLowerCase()) ||
                 room.otherParticipantName.includes(userEmail.split('@')[0]))
            );
            
            if (existingRoom) {
                console.log('‚úÖ Found existing room:', existingRoom);
                currentChatRoomId = String(existingRoom.chatRoomId);
                
                // Join WebSocket room
                if (chatWebSocketClient && chatWebSocketClient.isConnected) {
                    chatWebSocketClient.joinRoom(Number(currentChatRoomId));
                }
                
                // Load chat history
                loadChatHistory(currentChatRoomId);
                return;
            }
        }
        
        // If no existing room found, try to CREATE REAL chat room
        console.log('üèóÔ∏è No existing room found, creating REAL chat room for:', userName, userEmail);
        await createRealChatRoomWithStudent(userName, userEmail);
        
    } catch (error) {
        console.error('Error finding/creating chat room:', error);
        // Fallback to demo mode if API fails
        createNewChatSession(userName, userEmail);
    }
}

// Fallback function if we can't find student by email
// Function to CREATE REAL chat room via API
async function createRealChatRoomWithStudent(userName, userEmail) {
    try {
        console.log('üèóÔ∏è Creating REAL chat room via API for:', userName, userEmail);
        
        // Try to find student ID by email first
        const studentResponse = await fetch(`/api/students/findByEmail?email=${encodeURIComponent(userEmail)}`);
        
        let studentUserId = null;
        if (studentResponse.ok) {
            const studentData = await studentResponse.json();
            studentUserId = studentData.userId; // Use Account.userId, not Student.studentId
            console.log('üë§ Found student data:', studentData);
            console.log('üë§ Using student userId:', studentUserId);
        }
        
        // If we can't find student userId, use current user ID as fallback
        if (!studentUserId) {
            console.warn('‚ö†Ô∏è Could not find student userId, creating demo session');
            createNewChatSession(userName, userEmail);
            return;
        }
        
        // Create real chat room via API
        const createRoomResponse = await fetch('/api/chat/rooms', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                studentId: studentUserId,    // Student's Account.userId
                employerId: currentUserId,   // Employer's Account.userId  
                jobPostId: null             // General chat, not job-specific
            })
        });
        
        if (createRoomResponse.ok) {
            const newRoom = await createRoomResponse.json();
            console.log('‚úÖ Successfully created real chat room:', newRoom);
            
            currentChatRoomId = String(newRoom.chatRoomId);
            
            // Join WebSocket room
            if (chatWebSocketClient && chatWebSocketClient.isConnected) {
                chatWebSocketClient.joinRoom(Number(currentChatRoomId));
            }
            
            // Show ready chat interface
            showReadyChatInterface(userName);
            
        } else {
            console.error('‚ùå Failed to create chat room via API');
            // Fallback to demo mode
            createNewChatSession(userName, userEmail);
        }
        
    } catch (error) {
        console.error('Error creating real chat room:', error);
        // Fallback to demo mode
        createNewChatSession(userName, userEmail);
    }
}

// Function to show ready chat interface after room creation
function showReadyChatInterface(userName) {
    // LOAD CHAT HISTORY FIRST before showing UI
    console.log('üìú Loading chat history for room:', currentChatRoomId);
    loadChatHistory(currentChatRoomId);
    
    // Enable input for sending messages
    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
        messageInput.placeholder = `Nh·∫≠p tin nh·∫Øn cho ${userName}...`;
        messageInput.disabled = false;
        messageInput.focus();
    }
    
    // Update chat title and status
    document.getElementById('chatName').textContent = `üí¨ ${userName}`;
    document.getElementById('chatStatus').textContent = 'ƒêang ho·∫°t ƒë·ªông';
    document.getElementById('chatOverlay').classList.add('show');
    document.getElementById('chatOffcanvas').classList.add('show');
    
    console.log('‚úÖ Chat ready with history for:', userName);
}

// Function to create new chat session when no existing room found
function createNewChatSession(userName, userEmail) {
    console.log('üìù Creating new chat session for:', userName, userEmail);
    
    // Show chat interface ready for messaging
    const messagesContainer = document.getElementById('chatMessages');
    
    messagesContainer.innerHTML = `
        <div style="text-align: center; padding: 20px; color: #666;">
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 15px; margin-bottom: 20px;">
                <h5 style="margin: 0 0 10px 0;">üí¨ Chat v·ªõi ${userName}</h5>
                <p style="margin: 0; font-size: 14px; opacity: 0.9;">
                    B·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán ngay b√¢y gi·ªù!
                </p>
            </div>
            <div style="color: #999; font-size: 12px;">
                üí° Tin nh·∫Øn s·∫Ω ƒë∆∞·ª£c g·ª≠i real-time
            </div>
        </div>
    `;
    
    // Enable input for sending messages
    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
        messageInput.placeholder = `Nh·∫≠p tin nh·∫Øn cho ${userName}...`;
        messageInput.disabled = false;
        messageInput.focus(); // Auto focus v√†o input
    }
    
    // Set a temporary room ID for this conversation
    currentChatRoomId = 'new_' + userEmail.replace('@', '_').replace('.', '_');
    console.log('üìù Created new chat session with ID:', currentChatRoomId);
}

function createChatRoomByEmail(userEmail) {
    // Show a preparation message with ability to send messages
    const messagesContainer = document.getElementById('chatMessages');
    const userName = userEmail.split('@')[0]; // Get name part from email
    
    messagesContainer.innerHTML = `
        <div style="text-align: center; padding: 20px; color: #666;">
            <div style="background: #f0f0f0; padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <h5 style="margin: 0 0 10px 0; color: #333;">Chat v·ªõi ${userName}</h5>
                <p style="margin: 0; font-size: 14px;">
                    B·∫°n c√≥ th·ªÉ g·ª≠i tin nh·∫Øn cho ·ª©ng vi√™n n√†y. 
                    Tin nh·∫Øn s·∫Ω ƒë∆∞·ª£c g·ª≠i khi h·ªç ƒëƒÉng nh·∫≠p v√†o h·ªá th·ªëng.
                </p>
            </div>
            <div style="color: #999; font-size: 12px;">
                üí° H·ªá th·ªëng chat real-time ƒë√£ s·∫µn s√†ng
            </div>
        </div>
    `;
    
    // Enable input for sending messages
    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
        messageInput.placeholder = `Nh·∫≠p tin nh·∫Øn cho ${userName}...`;
        messageInput.disabled = false;
    }
    
    // Set a temporary room ID for this conversation
    currentChatRoomId = 'temp_' + userEmail.replace('@', '_').replace('.', '_');
    console.log('üìù Created temporary chat session:', currentChatRoomId);
}

function loadChatHistory(roomId) {
    // Use correct endpoint format
    fetch(`/api/chat/rooms/${roomId}/messages?page=0&size=50`)
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to load messages');
            }
            return response.json();
        })
        .then(messages => {
            const messagesContainer = document.getElementById('chatMessages');
            messagesContainer.innerHTML = ''; // Clear existing messages
            
            // Handle both array and paginated response
            const messageList = Array.isArray(messages) ? messages : (messages.content || []);
            
            messageList.forEach(message => {
                addMessageToUI(message);
            });
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        })
        .catch(error => {
            console.error('Error loading chat history:', error);
            // Show default messages or empty state
            const messagesContainer = document.getElementById('chatMessages');
            messagesContainer.innerHTML = `
                <div style="text-align: center; padding: 20px; color: #666;">
                    <p>Kh√¥ng th·ªÉ t·∫£i l·ªãch s·ª≠ chat</p>
                    <p><small>B·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán b·∫±ng c√°ch g·ª≠i tin nh·∫Øn ƒë·∫ßu ti√™n</small></p>
                </div>
            `;
        });
}

function closeChat() {
    // Leave WebSocket room
    if (chatWebSocketClient && currentChatRoomId) {
        chatWebSocketClient.leaveRoom();
        currentChatRoomId = null;
    }
    
    document.getElementById('chatOverlay').classList.remove('show');
    document.getElementById('chatOffcanvas').classList.remove('show');
}

function showError(message) {
    // Simple error display (you can make this more sophisticated)
    console.error(message);
    alert(message);
}

/**
 * ‚úÖ Mark messages as read
 */
function markMessagesAsRead(roomId) {
    if (!chatWebSocketClient || !chatWebSocketClient.isConnected) {
        console.warn('WebSocket not connected, cannot mark messages as read');
        return;
    }
    
    console.log('‚úÖ Marking messages as read for room:', roomId);
    
    // Send mark as read via WebSocket
    chatWebSocketClient.publish({
        destination: '/app/chat.markRead',
        body: JSON.stringify({ 
            chatRoomId: Number(roomId),
            userId: currentUserId 
        })
    });
}

function sendMessage(event) {
    event.preventDefault();
    
    const messageInput = document.getElementById('messageInput');
    const messageText = messageInput.value.trim();
    
    if (!messageText || !currentChatRoomId) return;
    
    // Handle demo chat sessions (fallback mode)
    if (String(currentChatRoomId).startsWith('new_') || String(currentChatRoomId).startsWith('temp_')) {
        console.log('üì§ Sending message in demo mode (API failed)');
        
        // Add message to UI immediately for demo
        addMessageToUI({
            content: messageText,
            senderId: currentUserId,
            sentAt: new Date().toISOString(),
            senderName: currentUserName
        });
        
        messageInput.value = '';
        
        // Show demo response
        setTimeout(() => {
            addMessageToUI({
                content: 'Tin nh·∫Øn demo - API t·∫°o chat room th·∫•t b·∫°i.',
                senderId: 0,
                sentAt: new Date().toISOString(),
                senderName: 'Demo'
            });
        }, 1500);
        
        return;
    }
    
    // Send via WebSocket for real rooms
    if (chatWebSocketClient && chatWebSocketClient.isConnected) {
        console.log('üì§ Sending message via WebSocket:', messageText);
        const success = chatWebSocketClient.sendMessage(messageText);
        if (success) {
            console.log('‚úÖ Message sent successfully');
            
            // Add message to UI immediately for better UX (optimistic update)
            addMessageToUI({
                content: messageText,
                senderId: currentUserId,
                sentAt: new Date().toISOString(),
                senderName: currentUserName
            });
            
            messageInput.value = '';
        } else {
            console.error('‚ùå Failed to send message');
        }
    } else {
        console.error('‚ùå WebSocket not connected');
        showError('Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn. Vui l√≤ng th·ª≠ l·∫°i.');
    }
}

// Removed duplicate handleNewMessage function - using the one with debug logic above

function addMessageToUI(message) {
    const messagesContainer = document.getElementById('chatMessages');
    const messageTime = new Date(message.sentAt).toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });
    
    // Determine if message is sent by current user
    const isSentByMe = message.senderId == currentUserId;
    const messageType = isSentByMe ? 'sent' : 'received';
    
    const messageElement = document.createElement('div');
    messageElement.className = `message ${messageType}`;
    messageElement.innerHTML = `
        <div class="message-bubble">
            ${message.content}
            <div class="message-time">${messageTime}</div>
        </div>
    `;
    
    // Remove empty state if exists
    const emptyState = messagesContainer.querySelector('div[style*="text-align: center"]');
    if (emptyState && emptyState.innerHTML.includes('Kh√¥ng th·ªÉ t·∫£i l·ªãch s·ª≠ chat')) {
        emptyState.remove();
    }
    
    messagesContainer.appendChild(messageElement);
    
    // Scroll to bottom
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function addMessageToChat(text, type) {
    // Legacy function for backward compatibility
    addMessageToUI({
        content: text,
        senderId: type === 'sent' ? currentUserId : 0,
        sentAt: new Date().toISOString()
    });
}

function showTypingIndicator() {
    document.getElementById('typingIndicator').style.display = 'block';
    const messagesContainer = document.getElementById('chatMessages');
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function hideTypingIndicator() {
    document.getElementById('typingIndicator').style.display = 'none';
}



// Close chat when pressing Escape
document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        closeChat();
    }
});
</script>
<script th:src="@{/js/language-dropdown.js}"></script>
</body>
</html>